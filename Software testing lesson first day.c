//#define _CRT_SECURE_NO_WARNINGS 1
//
////第一章 

//软件按照层次划分 分为系统软件和应用软件
//软件开不开放源代码和收不收费没关系
//
//一、软件缺陷的定义：
//1、软件未实现产品说明书要求的功能
//2、软件出现了产品说明书知名不应该出现的功能
//3、软件实现了产品说明书没有提到的功能，而且该功能也不应该实现。
//4、软件未实现产品说明书虽未明确提及但应该实现的目标
//5、软件难以理解、不宜使用、运行缓慢或者（从测试的角度看）最终用户会认为不好。
//总结：
//1、所有不满足需求或者超出需求的都是缺陷
//2、没有不存在缺陷的软件，只有迄今为止尚未发现的缺陷
//
//
//《测试数据选择的原理》
//《软件测试的艺术》 - 以后看这两个
//
//二、软件测试的定义和目的
//1、正向思维的定义
//出发点：使自己确信产品是能够正常工作的来评价一个程序和系统的特性和能力，并确定它是否达成期望的结果。
//正向思维是可取的，但是是不完全的。
//2、反向思维的定义
//（1）Glenford.J.Myers 《软件测试的艺术》
//（2）测试是为发现错误而执行一个程序或者系统的过程（抱着怀疑一切的态度对软件进行测试）
//（3）测试是为了证明程序有错，而不是证明程序无错误。
//（4）一个好的测试用例在于它能发现以前未发现的错误。
//（5） 一个成功的测试是发现了以前未发现的错误的测试。
//3、IEEE定义的软件测试
//在规定的条件下运行系统或构件的过程：观察和记录结果，并对系统或构件的某些方面给出评价。
//分析软件项目的过程：检测现有状况和所需状况之间的不同，并评估软件项目的特性。
//电气和电子工程师协会（IEEE，全称是Institude of Electrical and Electronics Engineers）是一个美国的电子技术与信息科学工程师的协会。
//4、广义的软件测试
//软件测试是对软件形成过程中的所有工作产品（包括程序以及相关文档）进行的测试，而不仅仅是对程序的运行进行测试
//.确认（Validation）  ：通过检查和提供客观证据来证实特定目的的功能或应用是否已经实现。（证实功能是否实现）
//.验证（Verification）：通过检查和提供客观证据来证实指定的需求是否满足。
//5、软件测试的目的
//以最少的人力、物力和时间找出软件中潜在的各种错误和缺陷，保证各种错误和缺陷得以修复，避免软件发布后由于潜在的软件错误和缺陷造成的隐患所带来的商业风险。
//同时利用测试过程中得到的测试结果和测试信息，作为后续项目开发和测试过程改进的重要输入，避免在将来的项目开发和测试中重复同样的错误。
//采用更加高效的测试管理手段，提高软件测试的效率和软件产品的质量。
//6、测试和调试的区别
//在主体、目标、方法和思路上有所不同
//
//
//
//测试
//调试
//主体
//测试人员
//开发人员
//目标
//找bug
//将错误修改正确
//方法等价类、边界值。。。。
//程序和逻辑算法
//思路
//反向思维正向思维
//测试是从已知的条件开始，使用预先定义的过程，并且有预知的结果；调试是从未知的条件开始，结束的过程可能不可预计。
//测试可以计划，可以预先制定测试用例和过程，工作进度可以度量；描述调试的过程或持续时间相对比较困难。
//测试的对象包括软件开发过程中的文档、数据以及代码，而调试的对象一般来说只是代码。
//
//7、软件测试的对象
//软件测试的对象一般包括源程序、目标程序、数据以及相关文档等。



//第二章   生命周期

//一、软件危机和软件工程
//1、软件危机
//是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。
//2、软件工程
//基于软件危机对于计算机发展的阻碍，1968年，在联邦德国召开的国际会议上，北大西洋公约组织的计算机科学家讨论软件危机问题。提出了软件工程这个名词，从此软件生产进入工程化时代。
//软件工程包括两方面内容：
//（1）软件开发技术：软件开发方法学、软件工具和软件工程环境
//（2）软件项目管理：软件质量、项目估算、进度控制、人员组织、配置管理、项目计划
//引起软件危机的主要问题是软件质量问题
//软件工程主要解决的就是软件质量问题
//软件测试是软件质量管理体系中一个非常重要的手段
//
//
//二、软件的生命周期
//
//
//
//三、软件生命周期模型
//1、瀑布模型
//
//
//最早提出的软件开发的过程模型。
////（1）存在的问题
//1 / 强调时间顺序的严格执行，前阶段不完成，后阶段不开始。
//2 / 将测试放在了编码之后。没有体现出测试贯穿软件生命周期的原则。可以避免需求的问题一直延续到代码完成才暴露或者被发现。
//学习要求：会画出瀑布模型。//
//（2）优点
//1 / 为项目提供了按阶段划分的检查点
//2 / 当前一阶段完成后，只需要去关注后续阶段。
//（3）缺点
//1 / 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。
//2 / 线性开发，用户等到整个过程的末期才能见到开发成果，从而增加了开发风险。
//3 / 瀑布模型不适应用户需求的变化。
//
//2、螺旋模型
//螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控。
//（1）引入了其他模型不具备的风险分析，使软件在无法排出重大风险时有机会停止，以减小损失。
//（2）螺旋模型更适合大型的昂贵的系统的软件应用。
//
//
//
//3、迭代模型
//迭代包括产生产品发布（稳定、可执行的产品版本）全部开发活动和要使用该发布必须的所有其他元素，强调开发的深入。（一次比一次深入）
//在某种程度上，开发迭代是一次完整地经过所有工作流程的的过程：需求分析、设计、实施和测试工作流程
//迭代过程具有以下优点：
//1 / 降低了在一个增量上的开支风险
//2 / 降低了产品无法按照既定进度进入市场的风险。
//3 / 加快了整个开发工作的进度。
//4 / 迭代过程这种模式使适应需求的变化会更容易些。
//
//
//4、敏捷模型 - Scrum
//敏捷宣言：也叫作敏捷软件开发宣言，正式宣布了对四种核心价值和十二条原则，可以指导迭代的以人为中心的软件开发方法。
//
//
//
//
//4、增量模型
//把软件分割成独立的模块，分批次的完成和交付。可以因需求而变化。
//缺点：打破原有的软件结构和框架，可能会带来一定的风险。
//
//
//增量模型一般会和迭代模型一起运用。
//（1）软件增加了新功能。
//（2）优化了......功能
//（3）修复了某些未知 / 已知bug
